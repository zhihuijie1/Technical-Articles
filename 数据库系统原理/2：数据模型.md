[TOC]



# 一：层次模型



![](D:/%E4%BD%A0%E5%A5%BDJava/1273.png)

**PCR：表示的是一对多的关系。**

**层次数据模型的模式：是一个二叉树结构**

![](D:/%E4%BD%A0%E5%A5%BDJava/1274.png)

但是在现实的世界中，有许多多对多的关系。

![](D:/%E4%BD%A0%E5%A5%BDJava/1275.png)

**所以科学家想到了一个办法就是采用虚拟指针的方法。**

**可以理解为是一个引用，虽然看上去有两个不同的对象，其实另一个对象只是一个引用指向的是另一个真正的对象。**

![](D:/%E4%BD%A0%E5%A5%BDJava/1276.png)



# 二：网状数据模型



可以看成是一个多维链表。

![](D:/%E4%BD%A0%E5%A5%BDJava/1277.png)

使用的是链表。拉一个链表出来，就将你的结果就带出来的。



![](D:/%E4%BD%A0%E5%A5%BDJava/1278.png)

以class901为头，拉一个链表出来，就讲这个班的学生都带出来了。

在网状数据库中对数据进行查询的时候，你要一层一层的遍历这个链表。

在层次数据模型中，要查询一个数据就要遍历那颗树。

**左边是学生，中间是link中间件，右边是课程。**

**通过link这个中间件，我们就可以实现多对多的关系。而且是左边对于中间件是一对多的关系，右边对于中间件也是一对多的关系。但是总的一看左边对右边以及右边对左边都是多对多的关系。**

<img src="D:/%E4%BD%A0%E5%A5%BDJava/1279.png" style="zoom:33%;" />

![](D:/%E4%BD%A0%E5%A5%BDJava/1280.png)

**注意这里的L就是Link中间件。**

john通过链表一串，选的课程是AI SF NK DB

pat通过链表一串，选的课程是DB C JV

DB通过链表一串，选这门课的学生有：John  pat

当关系变多的时候，就会有无数的链表相互串着，变的无比的复杂。

# 

# 三：关系数据模型



### 1：概念



![](D:/%E4%BD%A0%E5%A5%BDJava/1281.png)

在关系性数据库中全是表。

我们看到的都是一些表，因此屏蔽了很多的技术细节。

可以使用非过程性的语言SQL语言进行查询，注意层次数据模型，网状数据模型是过程性查询的，你需要自己写程序来查询。



### **2：理解软连接：**



![](D:/%E4%BD%A0%E5%A5%BDJava/1282.png)

中间的elective表就实现了软连接。讲学生表与课程表连接了起来。并实现了多对多的关系。



### **3：Attribute:属性，Domain：值域**



![](D:/%E4%BD%A0%E5%A5%BDJava/1284.png)

在关系模型中，现实世界中一个实体的特征通常被表示为属性。属性描述实体的属性或特征，并提供有关它的详细信息。在关系模型中，每个实体都被表示为一个表，其中每个列表示实体的一个属性。

例如，考虑一个名为"Person"的实体，具有属性如"姓名"、"年龄"、"地址"和"电子邮件"。在关系模型中，你会创建一个名为"Person"的表，其中每个列表示一个属性：

| 姓名  | 年龄 | 地址        | 电子邮件                                      |
| ----- | ---- | ----------- | --------------------------------------------- |
| John  | 30   | 123 Main St | [john@example.com](mailto:john@example.com)   |
| Alice | 25   | 456 Elm St  | [alice@example.com](mailto:alice@example.com) |
| Bob   | 40   | 789 Oak St  | [bob@example.com](mailto:bob@example.com)     |

这里，每一行表示"Person"实体的一个实例，而每个列代表一个属性。每个单元格中的值对应于每个人的特定属性值。

通过将实体的属性组织成表结构，关系模型允许使用关系数据库管理系统（RDBMS）有效地存储、检索和操作数据。

需要注意的是，关系模型提供了一种表示和组织数据的方式，但属性的解释和意义取决于上下文和所建模的实际实体。

**第一范式：不允许表中套表的情况出现，每一个属性都是原子的，比如所说学生姓名这个属性，就必须是原子的，不可以让学生姓名这个属性另建一个新表。：**

<img src="D:/%E4%BD%A0%E5%A5%BDJava/1283.png" style="zoom:33%;" />

### **4：主键：**



![](D:/%E4%BD%A0%E5%A5%BDJava/1285.png)

只有满足1，2这两个条件才有机会成为主键。

第一个条件就是说：一张表中的所有记录中同一个属性都是不一样的。

第二个条件就是说：一张表中的所有属性，只有一个属性满足条件一。

所以说明了一个问题就i是：主键只有一个。

如果条件二是假的，只满足条件一的话，举个例子：比如所name这个属性满足条件一，age不满足条件一，那么 { name age }所组成的集合就是一个超键。{name}是一个主键。

如果满足两个条件的属性有多个，那么只能有一个是主键，另一个称为辅键。

如果所有的属性组成的集合才能满足两个条件的话，那么这个集合被称为全键。



### 5：外键



![](D:/%E4%BD%A0%E5%A5%BDJava/1286.png)



举个例子解释一下外键。下面有两张表，一个是学生信息表，一个是课程表。

我再创建一个表：叫做学生课程对应表。这张表的属性有student ID  studentName   classes ID  classesName

其中 student ID 与 classes ID就可以作为外键，因为他们两个在各自的表中都是主键。我们自己创建的表通过外键指向其他表的主键。从而实现了查询的功能。

注意外键与主键是绑定的，任意一个不可以是null.

**主键是不可能为null的，如果主键是空的话，就不可能完整的表示一个记录了。比如说同一个属性有好几个都是空。**



<img src="D:/%E4%BD%A0%E5%A5%BDJava/759.png" style="zoom:80%;" />



### 6：关系代数



![](D:/%E4%BD%A0%E5%A5%BDJava/1295.png)





#### 练习



![](D:/%E4%BD%A0%E5%A5%BDJava/1292.png)

#### （1）**映射操作：**

对于S2这张表，我们想取出sname与rating这两个属性，如下图右上角所示。

如果我们只对age这个属性进行映射，就会得到下图右下角所示图片。重复的数据都删除了，为什么呢？

因为对于关系代数来说，在一张表中，如果两个元组（记录）的所有属性都相同，就说明这两个元组是一个元组，另一个没有意义。这跟java对象是不一样的，在java中对象的属性即使都是一样的，这两个对象也未必是一样的。但是在工业界是不会给你删除的，因为软件不知道你还用不用要被删除的数据，所以会给你保留着。

![](D:/%E4%BD%A0%E5%A5%BDJava/1293.png)

​	

#### （2）：选择操作

将满足条件的元组找出来。

注意返回的还是一张表，表就是关系型数据库的核心。

![](D:/%E4%BD%A0%E5%A5%BDJava/1294.png)

#### （3）：并交差操作

必须满足并兼容操作。

属性的个数以及属性的类型都是一样的。

![](D:/%E4%BD%A0%E5%A5%BDJava/1296.png)



#### （4）关系除法



![](D:/%E4%BD%A0%E5%A5%BDJava/1297.png)



### 7：关系演算

关系演算又分为：1：域关系演算  2：元组关系演算。、

关系代数的五个操作：并，差，交，除，笛卡尔乘积都可以用关系演算来一一对应上。

![](D:/%E4%BD%A0%E5%A5%BDJava/1305.png)

我们的SQL语言就是建立在关系演算上的。



#### 域关系演算

![](D:/%E4%BD%A0%E5%A5%BDJava/1303.png)

左边的一群x组成的集合表示的是：一群属性组成的集合，右边的p表示的是这群属性应该满足的条件。

举个例子：

![](D:/%E4%BD%A0%E5%A5%BDJava/1304.png)

注意会出现不安全的查询，比如说p条件你写的是真确的，但是会出现无限多的查询结果。

不安全的查询就是错误的。

![](D:/%E4%BD%A0%E5%A5%BDJava/1306.png)



#### 元组关系演算



![](D:/%E4%BD%A0%E5%A5%BDJava/1307.png)

|左侧的t[<attribute list>]指的是：由部分属性组成的元组。

|右侧的P(t)指的是：元组应该要满足的条件。

t[<attribute list>] | P(t) 最终的结果就是满足条件的元组集合。



# 四：对传统数据模型的总结



![](D:/%E4%BD%A0%E5%A5%BDJava/1308.png)



首先传统数据模型包括：层次模型，网状模型，关系模型。

传统数据模型主要是基于记录的，对应用开发以及用户不友好。

不能很好的表达实体之间的关系。比如说现实中有很多的父子关系，以及其他的关系，对于关系数据模型来说就是一群表，看起来地位都是平等的。比如你打开数据库一看有上万张表让你处理，每一张表之间都有关系，这是你是不是傻眼了，因为这些关系你压根看不见，你只是看到了一堆的表。



缺乏语义信息

数据类型少，难以满足应用的需求。



# 五：ER模型



## 1：ER图

![](D:/%E4%BD%A0%E5%A5%BDJava/1309.png)

相比于传统数据模型，一看这个图就知道是什么关系，语义丰富。



多个属性直接的关系也很丰富.

基数约束：

![](D:/%E4%BD%A0%E5%A5%BDJava/1310.png)









