[TOC]



![](D:/%E4%BD%A0%E5%A5%BDJava/975.png)

![](D:/%E4%BD%A0%E5%A5%BDJava/976.png)

![](D:/%E4%BD%A0%E5%A5%BDJava/977.png)

# 2：前缀和数组



![](D:/%E4%BD%A0%E5%A5%BDJava/980.png)

```java
// 前缀和数组
public class RangSum {
    public static int[] help;
    public static int rangSum(int[] array, int L, int R) {
        help = new int[array.length];
        help[0] = array[0];
        for (int i = 1; i < array.length; i++) {
            help[i] = help[i-1] + array[i];
        }
        return L == 0 ? help[R] : help[R] - help[L - 1];
    }
}
```

思路：

array：{1，2，3，4，5，6，7}

1：先创建一个前缀和数组 help：{1，3，6，10，15，21，28}

2：根据要求的L—R累加和的区间，如果L == 0，那么直接返回help[R]，如果L ！=0，那么就返回help[R] - help[L-1]

3：之所以采用前缀和数组的原因是：用空间换时间，空间复杂度是On但是时间复杂度却是O1，而传统的累加的方式，空间复杂度虽然是O1但是时间复杂度是On.



# 3：Math.random( ):等概率的返回[0 , 1)之间的数



```java
package Novice_class;
// Math.random(): 等概率的返回[0,1)上的每一个数，注意返回类型是double类型

public class RandToRand {
    //  Math.random() -> x属于[0,1)之间，P[0,x] = x
    // 现在想设计一个 Math.random() -> x属于[0,1)之间，P[0,x] = x^2
    public static void main(String[] args) {
        int testTime = 100000;
        int count1 = 0;
        int count2 = 0;
        int count3 = 0;
        for (int i = 0; i < testTime; i++) {
            double x = 0.3;
            if(Math.random() < x) {
                count1++;
            }
            if(xpoewrx2() < x) {
                count2++;
            }
            if(xpoewrx3() < x) {
                count3++;
            }
        }
        System.out.println(count1 * 1.0 / testTime);
        System.out.println(count2 * 1.0 / testTime);
        System.out.println(count3 * 1.0 / testTime);
    }

    public static double xpoewrx2() {
        return Math.max(Math.random(),Math.random());
    }
    public static double xpoewrx3() {
        return Math.max(Math.max(Math.random(),Math.random()),Math.random());				
    }
}
/*
0.30134
0.08862
0.02707
*/
```

![](D:/%E4%BD%A0%E5%A5%BDJava/982.png)

![	](D:/%E4%BD%A0%E5%A5%BDJava/983.png)

# 4：从a~b随机到c~d随机



```java
	// 有f1这么一个函数：等概率返回[1,5]之间的数字
    // 我们想要[0,6]等概率返回一个，注意只能使用f1方法改写
    public static int f1() {
        return (int)(Math.random() * 5) + 1;
    }

    // f2: 1，2 -> return 0    4,5 -> return 1   3 -> 重新加载
    // f2就是一个0 , 1发生器,并且是等概率的
    public static int f2() {
        int ans = f1();  // 1,2,3,4,5
        while(ans == 3) {
            ans = f1();
        }
        // 出来之后ans肯定不等于3
        return ans < 3 ? 0 : 1;
    }

	// 返回 0 - 7：之间的数字是等概率的
    public static int f3() {
        // 000 —— 111 ：0 - 7
        int ans = (f2() << 2) + (f2() << 1) + (f2() << 0);
        // 返回 0 - 7：之间的数字是等概率的
        return ans;
    }

    public static int f4() {
        int ans = f3();
        while(ans == 7) {
            ans = f3();
        }
        // 出来之后肯定没有7
        return ans;
    }

```

举一反三：

```java
	//有t1这么一个函数：等概率返回[1,24]之间的数字	
	// 33~57等概率获得一个数,整数,只能使用t1改写

    // 1-24等概率发生器
    public static int t1() {
        return (int)(Math.random() * 24) + 1;
    }

    // t2是一个0，1发生器
    // 12,13是[1,24]的一个中间值
    public static int t2() {
        int ans = t1();
        while(ans == 12 || ans == 13) {
            ans = t1();
        }
        // 出来之后肯定没有12 和 13
        return ans < 12 ? 0 : 1;
    }

    // 等概率的返回[0,24]
    public static int t3() {
        int ans = (t2() << 4) + (t2() << 3) + (t2() << 2) + (t2() << 1) + (t2() << 0);
        // ans : [0,31]
        while(ans > 24){
            ans = (t2() << 4) + (t2() << 3) + (t2() << 2) + (t2() << 1) + (t2() << 0);
        }
        return ans;
    }

    public static int t4() {
        return t3()+33;
    }
```

# 5：01不等概率随机到01等概率随机



![](D:/%E4%BD%A0%E5%A5%BDJava/984.png)

```java
	// 你只知道x会以固定的概率返回0或者1，并且返回0/1的概率不同
    public static int x() {
        return Math.random() < 0.84 ? 0 : 1;
    }

    // 等概率的返回 0 / 1
    public static int y() {
        int ans = x();
        while(ans == x()) {
            ans = x();
        }
        return ans;
    }
```

# 6：有序数组中找到num



```java
// arr保证有序，在arr数组中寻找num，二分查找
    public static boolean find(int[] arr, int num) {
        if(arr == null || arr.length == 0) {
            return false;
        }
        int L = 0;
        int R = arr.length - 1;
        while (L <= R) {
            int mid = (L + R) / 2;
            if(arr[mid] == num) {
                return true;
            }else if(arr[mid] < num) {
                L = mid +1;
            }else {
                R = mid - 1;
            }
        }
        return false;
    }
```

# 7：有序数组中找到>=num最左的位置



![](D:/%E4%BD%A0%E5%A5%BDJava/990.png)

首先通过二分查找找到的是mid == 5位置的数，arr【5】 >= 2 ,符合条件，让T记录一下这个位置，T = 5；

然后再去左边寻找，看看有没有arr>=2并且下标比5小的位置,如果有就让T记录一下这个位置，将最后的T的结

果返回。

```java
	// 有序数组中找到>=num最左的位置
    // 1 2 2 3 4 5 6 7  数组
    // 0 1 2 3 4 5 6 7 下标
    // num == 2  return 1
    public static int mostLeftNoLessNumIndex(int[] arr, int num) {
        if(arr == null || arr.length == 1) {
            return -1;
        }
        int L = 0;
        int R = arr.length - 1;
        // ans:是用来计数的，用来记录>=num的位置
        int t = -1;
        while(L <= R) {
            int mid = (L + R) / 2;
            if(arr[mid] >= num) {
                t = mid;
                R = mid - 1;
            }else {
                L = mid + 1;
            }
        }
        return t;
    }
```



# 8：有序数组中找到<=num最右的位置



```java
	// 有序数组中找到<=num最右的位置
    // 1 2 2 3 4 5 6 7  数组
    // 0 1 2 3 4 5 6 7 下标
    // num <= 2  return 2
    public static int nearestIndex(int[] arr, int value) {
        if(arr == null || arr.length == 1) {
            return -1;
        }
        int L = 0;
        int R = arr.length - 1;
        // ans:是用来计数的，用来记录>=num的位置
        int t = -1;
        while(L <= R) {
            int mid = (L + R) / 2;
            if(arr[mid] <= value) {
                t = mid;
                L = mid + 1;
            }else {
                R = mid - 1;
            }
        }
        return t;
    }
```



# 9：局部最小值问题



![](D:/%E4%BD%A0%E5%A5%BDJava/991.png)

![](D:/%E4%BD%A0%E5%A5%BDJava/992.png)

![](D:/%E4%BD%A0%E5%A5%BDJava/993.png)

![](D:/%E4%BD%A0%E5%A5%BDJava/994.png)

自写：

```java
	// arr 相邻的数不相等！ 返回一个局部最小的下标
    public static int oneMinIndex(int[] arr) {
        if(arr == null || arr.length == 0) {
            return -1;
        }
        if(arr.length == 1) {
            return 0;
        }
        int L = 0;
        int R = arr.length - 1;
        if(arr[L] < arr[L + 1]) {
            return L;
        }
        if(arr[R] < arr[R - 1]) {
            return R;
        }
        // 之后是两边下陷的情况
        while(L <= R) {
            int mid = (L + R) / 2;
            if (mid -1 >= L && mid +1 <= R && arr[mid] < arr[mid + 1] && arr[mid] < arr[mid - 1]) {
                return mid;
            }
            if(mid -1 >= L && arr[mid] > arr[mid - 1]) {
                R = mid - 1;
                continue;
            }
            if(mid +1 <= R && arr[mid] > arr[mid + 1]) {
                L = mid + 1;
            }
            // L与R相邻的时候，直接返回最小的那个
            if(mid == L || mid == R) {
                return arr[L] > arr[R] ? R : L;
            }
        }
        return -1;
    }
```

左神：

```java
// arr 相邻的数不相等！ 返回一个局部最小的下标
    public static int oneMinIndex2(int[] arr) {
        if(arr == null || arr.length == 0) {
            return -1;
        }
        if(arr.length == 1) {
            return 0;
        }
        int L = 0;
        int R = arr.length - 1;
        if(arr[L] < arr[L + 1]) {
            return L;
        }
        if(arr[R] < arr[R - 1]) {
            return R;
        }
        // 之后是两边下陷的情况
        while(L < R-1) {
            int mid = (L + R) / 2;
            if (arr[mid] < arr[mid + 1] && arr[mid] < arr[mid - 1]) {
                return mid;
            }
            if(arr[mid] > arr[mid - 1]) {
                R = mid - 1;
                continue;
            }
            if(arr[mid] > arr[mid + 1]) {
                L = mid + 1;
            }
        }
        return arr[L] < arr[R] ? L : R;
    }
```

![](D:/%E4%BD%A0%E5%A5%BDJava/995.png)

![](D:/%E4%BD%A0%E5%A5%BDJava/996.png)

总结一下：

```java
	public static int oneMinIndex3(int[] arr) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int N = arr.length;
        if (N == 1) {
            return 0;
        }
        //到这，arr的长度是大于等于2的
        if (arr[0] < arr[1]) {
            return 0;
        }
        if (arr[N - 1] < arr[N - 2]) {
            return N - 1;
        }
        int L = 0;
        int R = N - 1;
        int ans = -1;
        while (L <= R) {
            int mid = (L + R) / 2;
            //中间位置是否是最小，[mid-1] > [mid] < [mid+1]
            if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {
                ans = mid;
                break;

                //不同时小，下面两个判断选一个就行
            } else if (arr[mid] > arr[mid - 1]) {
                R = mid;
            } else {//arr[mid] > arr[mid + 1]
                L = mid;
            }
        }
        return ans;
    }
}
```

L == 0 ，R == n - 1

0 与 n - 1位置上一定不是局部最小值，而 [ 1 ,  n-2 ] 之间一定有局部最小值，所以 mid  (mid：锁定局部最小

值的)不可能来到下标 0 与 n - 1  的位置，下标 0 与 n - 1 作为一个缓冲区（如果来到0或n-1的旁边，0与n - 1

可作为一个缓冲区，就不会出现mid-1或者mid+1越界的情况）。如果mid位置是局部最小值就返回了，如果没

返回说明mid位置不是局部最小值，我们就令L == mid 或者是 R == mid，这样 L 与 R 也是一个缓冲区，L与R

之间一定有局部最小值。还有就是，不会有(L == 0&& R == 1 ) || (L == N-2 && R == N-1 )

的情况，如果出现上述的情况说明一定没有局部最小值（L与R是缓冲区，中间没有值），然而事实是一定有

局部最小值。

**这个方法的关键是：下标0，N-1的区域做缓冲区，L与R做缓冲区。所以没有越界的风险。**



```java
	public static int getLessIndex(int[] arr) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        if (arr.length == 1 || arr[0] < arr[1]) {
            return 0;
        }
        if (arr[arr.length - 1] < arr[arr.length - 2]) {
            return arr.length - 1;
        }
        int left = 1;
        int right = arr.length - 2;
        int mid = 0;
        while (left <= right) {
            mid = (left + right) / 2;
            if (arr[mid] > arr[mid - 1]) {
                right = mid - 1;
            } else if (arr[mid] > arr[mid + 1]) {
                left = mid + 1;
            } else {
                return mid;
            }
        }
        // 这个地方return谁都是对的，因为一定有区域最小值
        return left; 
    }
```

L == 1 ，R == n - 2

如果mid位置是局部最小值就返回了，如果没返回说明mid位置不是局部最小值，我们就

令L == mid + 1 或者是 R == mid - 1，mid一定不是局部最小值，但是mid+1与mid-1可能是局部最小值。所以

【L，R】L与R之间都是 “好的” 都是有可能是局部最小值的区域，剔除不是局部最小值的部分，在是局部最小

值的区域寻找。

**这个方法的关键：[L , R] L与R之间都是“好的”部分（可能是局部最小值的部分）不可能来到下标 0，n - 1位**

**置，并且下标 0，n - 1位置可以作为一个缓冲，所以不会出现越界的状况。**



```java
// arr 相邻的数不相等！ 返回一个局部最小的下标
    public static int oneMinIndex(int[] arr) {
        if(arr == null || arr.length == 0) {
            return -1;
        }
        if(arr.length == 1) {
            return 0;
        }
        int L = 0;
        int R = arr.length - 1;
        if(arr[L] < arr[L + 1]) {
            return L;
        }
        if(arr[R] < arr[R - 1]) {
            return R;
        }
        // 之后是两边下陷的情况
        while(L <= R) {
            int mid = (L + R) / 2;
            if (mid -1 >= L && mid +1 <= R && arr[mid] < arr[mid + 1] && arr[mid] < arr[mid - 1]) {
                return mid;
            }
            if(mid -1 >= L && arr[mid] > arr[mid - 1]) {
                R = mid - 1;
                continue;
            }
            if(mid +1 <= R && arr[mid] > arr[mid + 1]) {
                L = mid + 1;
            }
            // L与R相邻的时候，直接返回最小的那个
            if(mid == L || mid == R) {
                return arr[L] > arr[R] ? R : L;
            }
        }
        return -1;
    }
```

L == 0   R == n - 1

下标为0 和 n - 1的位置是一个缓冲区。

如果mid位置是局部最小值就返回了，如果没返回说明mid位置不是局部最小值，我们就

令L == mid + 1 或者是 R == mid - 1。

刚开始L == 0，R == n - 1是一个缓冲区，仅当R == mid - 1的时候，R失去了缓冲区的作用，但是L仍然是缓冲

区，因为R是“好的”，所以当R来到下标为1的位置就会出现越界的风险，因为此时mid指向L，即0下标。

而上面的方法1不会有问题的原因是：L与R都是缓冲区，不会有(L == 0&& R == 1 ) || (L == N-2 && R == N-1 )

的情况，如果出现上述的情况说明一定没有局部最小值（L与R是缓冲区，中间没有值），然而事实是一定有

局部最小值。

而本方法就会有(L == 0&& R == 1 )的情况出现，因为R 不是缓冲区。一遍是缓冲区一遍不是缓冲区，就有可

能越界。



写代码的时候别写方法三这种半吊子代码。





# 10：hashmap



哈希表中Integer,Double,String,Char等都是按值传递（只看内容不看地址），但是自己写的引用类型是按地址

传递。

```java
public static void main(String[] args) {
        String test1 = "wo";
        String test2 = "wo";
        // test1与test2在hashmap中看来是一样的。
        Integer a = 121231231;
        Integer b = 121231231;
         
}
```

​	

# 11：使用单链表实现队列的功能



```java
// 单链表实现队列和栈
public class LinkedListToQueueAndStack {
    public static class Node<V> {
        public V value;
        Node<V> next;

        public Node(V value) {
            this.value = value;
        }
    }

    public static class MyQueue<V> {

        Node<V> head;
        Node<V> tail;
        int usedSized;

        public MyQueue() {
            head = null;
            tail = null;
            usedSized = 0;
        }

        public boolean isEmpty() {
            return this.usedSized == 0;
        }

        public int size() {
            return usedSized;
        }

        public void offer(V value) {
            Node<V> cur = new Node<>(value);
            if(head == null) {
                head = cur;
                tail = cur;
            }else {
                tail.next = cur;
                tail = cur;
            }
            tail.next = null;
            usedSized++;
        }

        public V poll() {
            if(this.isEmpty()) {
                return null;
            }
            V cur = head.value;
            head = head.next;
            if(head == null) {
                tail = null;
            }
            usedSized--;
            return cur;
        }

        public V peek() {
            return this.isEmpty() ? null : this.head.value;
        }
    }
```



# 12：使用单链表实现栈的功能



```java
// 单链表实现栈

    public static class MyStack<V> {
        Node<V> head;
        int usedSize;

        public MyStack() {
            this.head = null;
            this.usedSize = 0;
        }

        public Boolean isEmpty() {
            return this.usedSize == 0;
        }

        public int size() {
            return this.usedSize;
        }

        public void push(V value) {
            Node<V> cur = new Node<>(value);
            cur.next = head;
            head = cur;
            usedSize++;
        }

        public V pop() {
            if(this.isEmpty()) {
                return null;
            }
            V value = this.head.value;
            head = head.next;
            //usedSize--;
            return value;
        }
        public V peek() {
            return this.isEmpty() ? null : this.head.value;
        }
    }
```



# 13：用双链表结构实现双端队列



![](D:/%E4%BD%A0%E5%A5%BDJava/1014.png)

```java
// 使用双链表实现双端队列
public class DoubleLinkedListToDeque<V> {

    public static class Node<V> {
        V value;
        Node<V> next;
        Node<V> last;

        public Node(V value) {
            this.value = value;
        }
    }

    Node<V> head;
    Node<V> tail;
    int usedSize;

    public DoubleLinkedListToDeque() {
        head = null;
        tail = null;
        usedSize = 0;
    }

    public boolean isEmpty() {
        return this.usedSize == 0;
    }

    public int size() {
        return this.usedSize;
    }

    public void pushHead(V value) {
        Node<V> cur = new Node<>(value);
        if(head == null) {
            tail = cur;
            head = cur;
        }else {
            cur.next = head;
            head.last = cur;
            head = cur;
        }
        usedSize++;
    }

    public void pushTail(V value) {
        Node<V> cur = new Node<>(value);
        if(head == null) {
            tail = cur;
            head = cur;
        }else {
            tail.next = cur;
            cur.last = tail;
            tail = cur;
        }
        usedSize++;
    }

    public V popHead() {
        if(this.head == null) {
            return null;
        }
        V cur = this.head.value;
        if(this.head == this.tail) {
            this.head = null;
            this.tail = null;
        }else {
            head = head.next;
            // 别忘了这一步
            head.last = null;
        }
        usedSize--;
        return cur;
    }

    public V popTail() {
        if(this.head == null) {
            return null;
        }
        V cur = this.tail.value;
        if(this.head == this.tail) {
            this.head = null;
            this.tail = null;
        }else {
            tail = tail.last;
            // 别忘了这一步
            tail.next = null;
        }
        usedSize--;
        return cur;
    }

    public V peekHead() {
        return this.isEmpty() ? null : this.head.value;
    }

    public V peekTail() {
        return this.isEmpty() ? null : this.tail.value;
    }
}
```



# 14：K个节点的组内逆序调整



> 给定一个单链表的头节点head，和一个正数k
>
> 实现k个节点的小组内部逆序，如果最后一组不够k个就不调整
>
> 例子:
>
> 调整前：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8，k = 3
>
> 调整后：3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8

![](D:/%E4%BD%A0%E5%A5%BDJava/1016.png)

```java
// K 个一组翻转链表

public class ReverseNodesInKGroup {

    public static class ListNode {
        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode start = head;
        ListNode end = getKGroupEnd(start , k);
        if(end == null) {
            return head;
        }
        // 说明有第一段
        head = end;
        reverse(start, end);
        while(start.next != null) {
            ListNode lastEnd = start;
            start = lastEnd.next;
            end = getKGroupEnd(start,k);
            if(end == null) {
                return head;
            }
            // 说明有第二段
            reverse(start, end);
            lastEnd.next = end;
        }
        return head;
    }

    // 得到一段区域的末尾节点
    public static ListNode getKGroupEnd(ListNode start, int k) {
        for (int i = 1; start != null && i < k; i++) {
            start = start.next;
        }
        return start;
    }

    // 把这一段进行反转
    public static void reverse(ListNode start, ListNode end) {
        ListNode pre = null;
        ListNode cur = start;
        ListNode next = null;
        while(pre != end) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        start.next = cur;
    }
}
```



# 15：两个链表相加



> 给定两个链表的头节点head1和head2，
>
> 认为从左到右是某个数字从低位到高位，返回相加之后的链表
>
> 例子   4 -> 3 -> 6    2 -> 5 -> 3
>
> 返回   6 -> 8 -> 9
>
> 解释   634 + 352 = 986

```java
/*
* 两个链表相加
* 给定两个链表的头节点head1和head2，
认为从左到右是某个数字从低位到高位，返回相加之后的链表
例子     4 -> 3 -> 6        2 -> 5 -> 3
返回     6 -> 8 -> 9
解释     634 + 352 = 986
* */
public class AddTwoNumbers {
    public static class ListNode {
        public int val;
        public ListNode next;

        public ListNode(int val) {
            this.val = val;
        }

        public ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    /*
    * 思路：1：找到长链表L，短链表S
    * 2：划分成3个阶段，阶段1：长链表L，短链表S都有，阶段2：长链表L有，短链表S无，阶段3：长链表L无，短链表S无
    * 3：注意进位，不额外开辟空间，直接将相加的结果放到长链表L上。
    * */
    public static ListNode addTwoNumbers(ListNode head1, ListNode head2) {
        // 标注长短链表
        ListNode L = listLength(head1) > listLength(head2)  ? head1 : head2;
        ListNode S = L == head1 ? head2 : head1;
        // 标注当前链表的指向节点
        ListNode curL = L;
        ListNode curS = S;
        // 进位
        int carry = 0;
        // 当前长节点要填的数
        int curNuber = 0;
        // 一直记录着长链表的尾节点，用于连接第三阶段的节点
        ListNode last = L;
        // 第一阶段：长链表L，短链表S都有
        while(curS != null) {
            int curNum = curL.val + curS.val + carry;
            carry = curNum / 10;
            curNuber = curNum % 10;
            curL.val = curNuber;
            last = curL;
            curL = curL.next;
            curS = curS.next;
        }
        // 第二阶段：长链表L有，短链表S无
        while(curL != null) {
            int curNum = curL.val + carry;
            carry = curNum / 10;
            curNuber = curNum % 10;
            curL.val = curNuber;
            last = curL;
            curL = curL.next;
        }
        // 第三阶段
        if(carry == 1) {
            ListNode node = new ListNode(1);
            last.next = node;
        }
        return L;
    }


    // 计算链表的长度
    public static int listLength(ListNode head) {
        if (head == null) {
            return 0;
        }
        int count = 0;
        while(head != null) {
            count++;
            head = head.next;
        }
        return count;
    }
}
```



# 16：位图的实现



```java
public class BitMap {
    private long[] bits;
    public BitMap(int max) {
        // max + 64 -> 当max == 63时，我们需要1个空间，当max == 0时我们需要1个空间
        bits = new long[(max + 64) >> 6];
    }

    public void add(int num) {
        /*
        // 属于哪个数组的下标
        int flg1 = num >> 6;
        // 属于当前数组下标下的哪个位置
        int flg2 = num & 63;
        bits[flg1] = (1L << flg2) | bits[flg1];
        */
        bits[num >> 6] |= (1L << (num & 63));
    }

    public void delete(int num) {
        /**
         * int flg1 = num >> 6;
         * int flg2 = num & 63;
         * bits[flg1] = bits[flg1] & ~(1L << flg2);
         */
        bits[num >> 6] &= ~(1L << (num & 63));
    }

    public boolean contains(int num) {
        return (bits[num >> 6] & (1L << (num & 63))) != 0;
    }
}
```



# 17：位运算实现加法



![](D:/%E4%BD%A0%E5%A5%BDJava/1023.png)

**加法运算 -> 无进位相加的信息（异或运算） +  进位信息（与运算）**

![](D:/%E4%BD%A0%E5%A5%BDJava/1019.png)

![](D:/%E4%BD%A0%E5%A5%BDJava/1020.png)

![](D:/%E4%BD%A0%E5%A5%BDJava/1021.png)

![](D:/%E4%BD%A0%E5%A5%BDJava/1022.png)

**a + b 可以不断的向下转化成无进位加信息+进位信息，但底层并没有加号这一说法（我们无法直接进行相加），所以我们需要一直往下进行转换直至进位信息是0的时候，我们得到的无进位加信息就是我们的答案。**

```java
// 用位运算实现 + - * /
public class BitAddMinusMultiDiv {

    public static int add(int a, int b) {
        int sum = a;
        while(b != 0) {
            sum = a ^ b; // 无进位相加信息
            b = (a & b) << 1; // 进位信心
            a = sum;
        }
        return sum;
    }
    
    // 判断是否是负数
    public static boolean isNeg(int n) {
        return n < 0;
    }

    // 取相反数
    public static int negNum(int n) {
        return add((~n),1);
    }
    // 减法就相当于：加一个相反数
    public static int minus(int a, int b) {
        return add(a,negNum(b));
    }
    // 乘法
    public static int multi(int a, int b) {
        int sum = 0;
        while(b != 0) {
            if((b & 1) != 0) {
                sum = add(sum , a);
            }
            b >>>= 1;
            a <<= 1;
        }
        return sum;
    }

    public static int div(int a, int b) {
        int x = isNeg(a) ? negNum(a) : a;
        int y = isNeg(b) ? negNum(b) : b;
        // x / y
        int ans = 0;
        for (int i = 30; i >= 0; i--) {
            if((x >> i) >= y) {
                ans |= (1 << i);
                x = minus(x,y << i);
            }
        }
        return isNeg(a) != isNeg(b) ? negNum(ans) : ans;
    }

    public static int divide(int a, int b) {
        if(a == Integer.MIN_VALUE && b == Integer.MIN_VALUE) {
            return 1;
        }else if(b == Integer.MIN_VALUE) {
            return 0;
        }else if(a == Integer.MIN_VALUE) {
            if(b == negNum(1)) {
                return Integer.MAX_VALUE;
            }else {
                /*
                * c = (a + 1) / b
                * d = a - b * c
                * e = d / b
                * return e + c
                * */
                int c = div(add(a , 1), b);
                return add(c , div(minus(a,multi(b,c)),b));
            }
        }else {
            return div(a , b);
        }
    }
}
```

# 18：位运算实现乘法



<img src="D:/%E4%BD%A0%E5%A5%BDJava/1024.png" style="zoom: 50%;" />

```java
 	public static int multi(int a, int b) {
        int sum = 0;
        while(b != 0) {
            if((b & 1) != 0) {
                sum = add(sum , a);
            }
            b >>>= 1;
            a <<= 1;
        }
        return sum;
    }
```

# 19：位运算实现除法



```java
public static int div(int a, int b) {
        // 将负数全部转化成正数，这样好分析
        int x = isNeg(a) ? negNum(a) : a;
        int y = isNeg(b) ? negNum(b) : b;
        // x / y
        int ans = 0;
        for (int i = 30; i >= 0; i--) {
            if((x >> i) >= y) {
                ans |= (1 << i);
                x = minus(x,y << i);
            }
        }
        return isNeg(a) != isNeg(b) ? negNum(ans) : ans;
    }

    public static int divide(int a, int b) {
        if(a == Integer.MIN_VALUE && b == Integer.MIN_VALUE) {
            return 1;
        }else if(b == Integer.MIN_VALUE) {
            return 0;
        }else if(a == Integer.MIN_VALUE) {
            if(b == negNum(1)) {
                return Integer.MAX_VALUE;
            }else {
                /*
                * c = (a + 1) / b
                * d = a - b * c
                * e = d / b
                * return e + c
                * */
                int c = div(add(a , 1), b);
                return add(c , div(minus(a,multi(b,c)),b));
            }
        }else {
            return div(a , b);
        }
    }
```



# 20：equals（）与 比较器区别



**equals( )方法主要是比较两个对象是不是相等。**

**而comparator比较器主要是指明如何进行比较，比如说是由小到大排列还是由大到小排列。**



# 21：合并多个有序链表



> 给你一个链表数组，每个链表都已经按升序排列。
>
> 请你将所有链表合并到一个升序链表中，返回合并后的链表。

<img src="D:/%E4%BD%A0%E5%A5%BDJava/1033.png" style="zoom:50%;" />

```java

import java.util.Comparator;
import java.util.PriorityQueue;

//  合并 K 个升序链表
public class MergeKSortedLists {
    public static class ListNode {
        public int val;
        public ListNode next;
    }

    public ListNode mergeKLists(ListNode[] lists) {
        if(lists == null) {
            return null;
        }
        PriorityQueue<ListNode> heap = new PriorityQueue<>(new Comparator<ListNode>() {
            // 节点值小的放在前面
            @Override
            public int compare(ListNode o1, ListNode o2) {
                return o1.val - o2.val;
            }
        });
        // 所有链表的头节点入堆
        for (int i = 0; i < lists.length; i++) {
            if(lists[i] != null) {
                heap.add(lists[i]);
            }
        }
        // 当所有都节点都是空的时候
        if(heap.isEmpty()) {
            return null;
        }

        ListNode head = heap.poll();
        ListNode cur = head;
        while(!heap.isEmpty()) {
            if(cur.next != null) {
                heap.add(cur.next);
            }
            ListNode node = heap.poll();
            cur.next = node;
            cur = node;
        }
        return head;
    }
}
```

# 22：从前序与中序遍历序列构造二叉树



https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

<img src="D:/%E4%BD%A0%E5%A5%BDJava/1035.png" style="zoom:50%;" />

```java
// 思路
// 1：创建一个方法f，这个方法的作用是：有一棵树，先序结果是pre[L1...R1]，中序结果是in[L2...R2]，请你建出这棵树。
 f(int[] pre, int L1, int R1, int[] in, int L2, int R2,HashMap<Integer,Integer> hashMap) 
// 2：根据先序结果找到其头节点：head，再在中序结果中找到该头节点所在位置:find. 这样find左边是左树区域，右边是右树区域
// 3：左树的先序遍历结果：pre[L1+1 , L1+find-L2],中序遍历结果：in[L2 , find - 1],根据这两个结果再次调用f方法，即可       得到建好的左树。同理也能得到建好的右树。
   head.left = f(pre,L1 + 1, L1 + find - L2, in, L2, find - 1, hashMap);
   head.right = f(pre, L1 + find - L2 + 1, R1, in, find + 1, R2, hashMap);
// 4：最后返回头节点。
```

```java
// 注意点1： 如下图：
	if(L1 > R1) {
         return null;
     }
// 当L1 > R1时压根没有就没有左树或是右树，直接返回null,还需要注意的是，当没有左树的时候f(pre, L1, R1, in, L2, R2);
// L1 > R1 && L2 > R2是同时发生的，所以条件只写一个就行L1 > R1。
```

![](D:/%E4%BD%A0%E5%A5%BDJava/1036.png)

```java
// 从前序与中序遍历序列构造二叉树
public class ConstructBinaryTreeFromPreorderAndInorderTraversal {
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 建立hashmap是在中序遍历的结果中找头节点用的，这样避免遍历中序结果，直接在hashmap中找就OK，用空间换时间。
        HashMap<Integer,Integer> hashMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            hashMap.put(inorder[i],i);
        }
        return f(preorder,0, preorder.length-1, inorder,0,inorder.length-1,hashMap);
    }

    // 有一棵树，先序结果是pre[L1...R1]，中序结果是in[L2...R2]
    // 请你建出这棵树
    public TreeNode f(int[] pre, int L1, int R1, int[] in, int L2, int R2,HashMap<Integer,Integer> hashMap) 	{
        if(pre == null || in == null || pre.length != in.length) {
            return null;
        }
        if(L1 == R1) {
            return new TreeNode(pre[L1]);
        }
        // 注意点1：
        if(L1 > R1) {
            return null;
        }
        TreeNode head = new TreeNode(pre[L1]);
        // 找到中序遍历中头节点的位置
        int find = hashMap.get(pre[L1]);
        head.left = f(pre,L1 + 1, L1 + find - L2, in, L2, find - 1, hashMap);
        head.right = f(pre, L1 + find - L2 + 1, R1, in, find + 1, R2, hashMap);
        return head;
    }
}
```



# 23：打印二叉树的函数，验证的直接代



```java
// 打印二叉树的函数
    public static void printTree(TreeNode head) {
        System.out.println("打印二叉树，看的时候请把图像顺指针转90度:");
        printInOrder(head, 0, "H", 17);
        System.out.println();
    }

    // 打印二叉树的函数
    public static void printInOrder(TreeNode head, int height, String to, int len) {
        if (head == null) {
            return;
        }
        printInOrder(head.right, height + 1, "v", len);
        String val = to + head.val + to;
        int lenM = val.length();
        int lenL = (len - lenM) / 2;
        int lenR = len - lenM - lenL;
        val = getSpace(lenL) + val + getSpace(lenR);
        System.out.println(getSpace(height * len) + val);
        printInOrder(head.left, height + 1, "^", len);
    }

    // 打印二叉树的函数
    public static String getSpace(int num) {
        String space = " ";
        StringBuffer buf = new StringBuffer("");
        for (int i = 0; i < num; i++) {
            buf.append(space);
        }
        return buf.toString();
    }
```



# 24：二叉树按层遍历并收集节点



https://leetcode.com/problems/binary-tree-level-order-traversal-ii

> 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
>
> <img src="D:/%E4%BD%A0%E5%A5%BDJava/1042.png" style="zoom:33%;" />
>
> 输入：root = [3,9,20,null,null,15,7]              输出：[[15,7],[9,20],[3]]
> 

![](D:/%E4%BD%A0%E5%A5%BDJava/1043.png)

```java
// 思路
// 1：想实现元素由上到下，由左到右，一层一层的放进链表中。
// 2：先创建一个队列，把头节点放入队列中，计算队列的大小，
// 3：在弹出这个节点的同时，进行如下操作：如果这个节点有左节点，就把左节点就把左节点放入队列中，如果有右节点，就把右节       点放入队列中。
// 4：计算队列的大小，重复上述操作。
```

```java
public class BinaryTreeLevelOrderTraversalII {
    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        TreeNode(int val) {
            this.val = val;
        }
    }
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if(root == null) {
            List<List<Integer>> lists = new LinkedList<>();
            return lists;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        // list存放结果
        List<List<Integer>> list = new LinkedList<>();
        // 先把头节点放入队列中
        queue.add(root);
        while(!queue.isEmpty()) {
            // 记录每一层的节点个数
            int size = queue.size();
            // 记录当前这一层的节点
            List<Integer> listone = new LinkedList<>();
            for (int i = 0; i < size; i++) {
                TreeNode cur = queue.poll();
                // 有左先加左，有右后加右
                if(cur.left != null) {
                    queue.add(cur.left);
                }
                if(cur.right != null) {
                    queue.add(cur.right);
                }
                listone.add(cur.val);
            }
            // 头插法
            list.add(0,listone);
        }
        return list;
    }
}
```

# 25：平衡二叉树



https://leetcode.com/problems/balanced-binary-tree



> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 本题中，一棵高度平衡二叉树定义为：
>
> > 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。
>
> <img src="D:/%E4%BD%A0%E5%A5%BDJava/1054.png" style="zoom:50%;" />
>
> 输入：root = [3,9,20,null,null,15,7]
> 输出：true



```java
// 思路
// 1: 判断是否是平衡二叉树的标准是：每一个树都是平衡树总体上才是平衡树。
// 2：判断以当前节点为头节点的二叉树是否是平衡二叉树的标准是：1：当前节点的左右子树是否是平衡二叉树 2：当前节点左右子树	     的高度差是否不超过1.
// 3：根据2可知，每个节点应该返回两个东西 1：boolean isBalanced(以当前节点为头节点的树是否是平衡树) 2：int 			  height(以当前节点为头节点的树的高度)，所以我们写了一个Info内部类，作为返回值类型。
	public static class Info {
        boolean isBalanced;
        int height;

        public Info(boolean isBalanced, int height) {
            this.isBalanced = isBalanced;
            this.height = height;
        }
    }
// 4：递归讲究每个节点都是 “同等全”，当前就满足递归，所以采用递归的方法。
```



```java
package Novice_class;

// 平衡二叉树
public class BalancedBinaryTree {

    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static class Info {
        boolean isBalanced;
        int height;

        public Info(boolean isBalanced, int height) {
            this.isBalanced = isBalanced;
            this.height = height;
        }
    }

    public boolean isBalanced(TreeNode root) {
        return process(root).isBalanced;
    }

    // 以当前节点为头节点的树是否是平衡树 返回两个结果 1：Boolean类型的是否是平衡树 2：这棵树的高度
    public static Info process(TreeNode root) {
        if (root == null) {
            return new Info(true, 0);
        }
        Info leftTree = process(root.left);
        Info rightTree = process(root.right);
        // 统计Info中的boolean isBalanced。
        boolean B = ((Math.abs(leftTree.height - rightTree.height) <= 1) && leftTree.isBalanced && 							   rightTree.isBalanced) ? true : false;
        // 统计Info中的int height。
        int H = Math.max(leftTree.height, rightTree.height) + 1;
        return new Info(B, H);
    }
}
```



# 26：验证二叉搜索树



https://leetcode.cn/problems/validate-binary-search-tree/description/

> 给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。
>
> **有效** 二叉搜索树定义如下：
>
> - 节点的左子树只包含 **小于** 当前节点的数。
> - 节点的右子树只包含 **大于** 当前节点的数。
> - 所有左子树和右子树自身必须也是二叉搜索树。

```java
// 思路
// 1：判断整棵树是否是二叉搜索树的标准：每一个树都是二叉搜索树。
// 2：判断以当前节点为头节点的二叉树是否是搜索树的标准：1：其左右子树是否是搜索树 2：左子树中的最大值小于当前节点的值       3：右子树中的最小值大于当前节点的值。
// 3：根据递归的 “同等全” 标准，可知每个节点都要返回3样东西：1：以当前节点为头节点的树是否是搜索树 2：以当前节点为头节	  点的树中的最大值 3：以当前节点为头节点的树中的最小值。因此我们设计了Info作为每个节点的返回值类型。
	public static class Info {
        public boolean isBST;
        public int max;
        public int min;

        public Info(boolean isBST, int max, int min) {
            this.isBST = isBST;
            this.max = max;
            this.min = min;
        }
    }
```



```java
package Novice_class;

// 验证二叉搜索树
public class IsBinarySearchTree {

    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static class Info {
        public boolean isBST;
        public int max;
        public int min;

        public Info(boolean isBST, int max, int min) {
            this.isBST = isBST;
            this.max = max;
            this.min = min;
        }
    }

    public boolean isValidBST(TreeNode root) {
        return process(root).isBST;
    }

    // 左子树都是二叉搜索树，并且左子树中最大的数小于当前节点
    // 右子树都是二叉搜索树，并且右子树中最小的数大于当前节点，
    public static Info process(TreeNode x) {
        if (x == null) {
            // 不知道返回的最大值与最小值是多少，只能先返回null
            return null;
        }
        Info leftTree = process(x.left);
        Info rightTree = process(x.right);
        // 统计Info中的 boolean isBST。
        boolean leftB = (leftTree != null) ? leftTree.max < x.val : true;
        boolean rightB = (rightTree != null) ? rightTree.min > x.val : true;
        boolean isBST = (leftTree == null || leftTree.isBST) && (rightTree == null || rightTree.isBST) && leftB && rightB;
        // 统计Info中的max与min。这个地方设计的很巧妙
        int max = x.val;
        int min = x.val;
        if (leftTree != null) {
            max = Math.max(leftTree.max, x.val);
            min = Math.min(leftTree.min, x.val);
        }
        if (rightTree != null) {
            max = Math.max(rightTree.max, max);
            min = Math.min(rightTree.min, min);
        }
        return new Info(isBST, max, min);
    }
}
```



# 27：路径总和



https://leetcode.cn/problems/path-sum/

> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。
>
> <img src="D:/%E4%BD%A0%E5%A5%BDJava/1052.png" style="zoom:50%;" />
>
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
> 输出：true
> 解释：等于目标和的根节点到叶节点路径如上图所示。

```java
// 思路
// 1：之前的递归采用的是 “同等全”的战略，因为一直到null节点我们才返回，这题的递归采用的是 “叶子节点” 与 “非叶子节点”    分别采取不同的战略。到叶子节点处理完我们就返回。
// 2：非叶子节点我们采用的是：
      sum += root.val;
//  3：叶子节点我们采用的是：
		if(root.left == null && root.right == null) {
            if(root.val + sum == targetSum) {
                T = true;
            }
            return;
        }
```



```java
public class PathSum {

    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static boolean T = false;
    
    public boolean hasPathSum(TreeNode root, int targetSum) {
        T = false;
        process(root, targetSum, 0);
        return T;
    }
    // targetSum:记录的是目标值
    // sum：记录的是现阶段值的总和
    public static void process(TreeNode root, int targetSum, int sum) {
        if(root == null) {
            return;
        }
        // 叶子节点
        if(root.left == null && root.right == null) {
            if(root.val + sum == targetSum) {
                T = true;
            }
            return;
        }
        // 非叶子节点
        sum += root.val;
        process(root.left, targetSum, sum);
        process(root.right, targetSum, sum);
    } 
}
```



# 28： 路径总和 II



https://leetcode.cn/problems/path-sum-ii/

> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
>
> <img src="D:/%E4%BD%A0%E5%A5%BDJava/1053.png" style="zoom:50%;" />
>
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
> 输出：[[5,4,11,2],[5,8,4,5]]



```java
//思路
// 1：这题的递归采用的是 “叶子节点” 与 “非叶子节点” 分别采取不同的战略。到叶子节点处理完我们就返回。
// 2：非叶子节点：
        preSum = preSum + x.val;
        path.add(x.val);
// 3：叶子节点：
		if (x.left == null && x.right == null) {
            if (x.val + preSum == sum) {
                path.add(x.val);
                // 返回一个新的地址
                ans.add(copyList(path));
                // 返回之前我们要清理现场
                path.remove(path.size() - 1);
            }
            return;
        }
// 4：最后整个节点都弄完以后，我们也要清理现场
```



左神的方法：

```java
package Novice_class;

import java.util.ArrayList;
import java.util.List;

public class PathSumII {
    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        TreeNode(int val) {
            this.val = val;
        }
    }

    public static List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        List<Integer> path = new ArrayList<>();
        process(root, sum, 0, path, ans);
        return ans;
    }

    // 左子树中有没有这个路径，右子树中有没有这个路径
    // sum：目标值  preSum：现阶段值的总和  path:跟踪用的链表   ans：最终要返回的链表
    public static void process(TreeNode x, int sum, int preSum, List<Integer> path, List<List<Integer>> ans) {
        if (x == null) {
            return;
        }
        // 来到叶子节点
        if (x.left == null && x.right == null) {
            if (x.val + preSum == sum) {
                path.add(x.val);
                // 返回一个新的地址
                ans.add(copyList(path));
                // 返回之前我们要清理现场
                path.remove(path.size() - 1);
            }
            return;
        }
        // 非叶子节点
        preSum = preSum + x.val;
        path.add(x.val);
        process(x.left, sum, preSum, path, ans);
        process(x.right, sum, preSum, path, ans);
        // 整个节点弄完之后，我们也要清理现场
        path.remove(path.size() - 1);
        return;
    }

    public static List<Integer> copyList(List<Integer> path) {
        List<Integer> cur = new ArrayList<>();
        for (int i = 0; i < path.size(); i++) {
            cur.add(i, path.get(i));
        }
        return cur;
    }
}
```

​		

自己写的方法，跟左神的差不多，就是 List<List<Integer>> lists 单独用static修饰，用作全局变量。需要注意的是这个lists需要每次都要清空一下，因为leecode底层对数器会多次调用pathSum方法，导致之前的lists结果有残留。

```java
	public static List<List<Integer>> lists = new LinkedList<>();

    public static List<List<Integer>> pathSum(TreeNode root, int sum) {
        // 每次都清空一下。
        lists.clear();
        if (root == null) {
            return lists;
        }
        List<Integer> path = new LinkedList<>();
        process(root, sum, 0, path);
        return lists;
    }

    public static void process(TreeNode x, int sum, int preSum, List<Integer> path) {
        if (x == null) {
            return;
        }
        // 叶子节点
        if (x.left == null && x.right == null) {
            if (x.val + preSum == sum) {
                path.add(x.val);
                lists.add(copy(path));
                path.remove(path.size() - 1);
            }
            return;
        }
        // 非叶子节点
        path.add(x.val);
        preSum += x.val;
        process(x.left, sum, preSum, path);
        process(x.right, sum, preSum, path);
        path.remove(path.size() - 1);
    }

    public static List<Integer> copy(List<Integer> path) {
        List<Integer> ans = new LinkedList<>();
        for (Integer num : path) {
            ans.add(num);
        }
        return ans;
    }
```











